#' Predict temperature-dependent development rates of the diamondback moth
#' @description
#' \code{predict_dev} is the main modelling function interface in
#' the \code{dbmdev} package.
#' It is used to predict temperature-dependent development rates of individual
#' life stages at hourly time steps, either forward or back in time, starting
#' from a user-specified bio-fix (time point and insect developmental stage).
#' It takes a single temperature data series.
#'
#' @param df A \code{data.frame} of hourly temperature observations with
#' three variables named "datetime" (POSIX), "obs" (numeric
#' temperature observations in degrees Celsius), and "location_key" (a
#' character string that uniquely identifies a location).
#' Hourly temperatures can be interpolated from daily maximum minimum
#' temperatures using the \code{\link{hourly}} function.
#'
#' @param FUN The name of the function used to model temperature-dependent
#' development responses (character or unquoted function name).
#' Only model "briere2" is implemented currently.
#'
#' @param params A \code{matrix} containing the developmental
#' parameters of the briere2 model for individual stages of diamondback moth.
#' Fitted parameters for diamondback moth are generated by default
#' by a call to \code{\link{dev_params}}.
#' The four parameters are:
#' \emph{a}, a constant from the model;
#' \emph{Tmin}, the minimum threshold temperature for development in degrees Celsius;
#' \emph{Tmax}, the maximum threshold temperature for development in degrees Celsius;
#' \emph{m}, the power coefficient.
#' Named matrix rows hold the parameters for each life stage.
#'
#' @param start_date The starting date for development in
#' YYYY-MM-DD format (character)
#'
#' @param start_hour The starting hour for development from 1-23
#' (numeric). The default value is 12 (midday).
#'
#' @param start_stage The starting life stage for development (character).
#' Must be a life stage for which parameters exist in the \code{params} object
#' Run \code{row.names(devparams())} to see possible values.
#'
#' @param start_dev The proportion (numeric) of stage development from which to commence
#' development predictions, ranging from 0 (no development) to 1
#' (development complete). By default, if not set, \code{start_dev} is set to
#' 0 if direction is "forward" in time and 1 if direction is "back", so that the
#' full developmental period of start_stage is included in predictions.
#'
#' @param gens The number of complete generations to predict (numeric). This
#' number is limited by the length of the temperature data time series.
#'
#' @param direction The direction in time, either "forward" or "back"
#' (character). The default value is "forward".
#'
#' @param keep The results to output, either "increments", "stages", "gens",
#' "all". The default value "stages" outputs a
#' \code{data.frame} displaying the time steps when development of life stages
#' commenced and completed. Specifiying "gens" outputs a \code{data.frame}
#' summarising the generation times, and "increments" outputs all hourly and
#' cumulative development increments. Specifying "all" outputs a list
#' with all three data.frames.
#'
#' @param ... Passed to [lubridate::as_date()]
#
#'
#' @return \code{data.frame} or \code{list}.
#' @export
#'
#' @examples
#'
#' # Sample hourly temperatures at a given location
#' d1 <- daily(days = 200, start_date = "2023-09-01")
#' h1 <- hourly(d1)
#'
#' # See the life stages
#' dev_params() # developmental parameters for diamondback moth
#' row.names(dev_params()) # possible values for "start_stage"
#'
#' # Predict forward 1 generation from the egg stage
#' pred <- predict_dev(h1, start_date = "2023-09-05")
#' pred$stages
#' pred$generations
#'
#' # Predict forward 2 generations from the mid-point of the "instar3" stage
#' pred2 <- predict_dev(
#'   h1,
#'   start_date = "2023-09-02",
#'   start_stage = "instar3",
#'   start_dev = 0.5,
#'   gens = 2
#'  )
#' pred2$stages
#' pred2$generations
#'
#' # Predict forward 4 generations from "instar4" and output generation times
#' predict_dev(
#'   h1,
#'   start_date = "2023-10-01",
#'   start_stage = "instar4",
#'   gens = 4,
#'   keep = "gen"
#'  )
#'
#' # Predict back in time 5 generations from the instar1_2 stage.
#' # A warning is thrown if you try to predict beyond the available
#' # temperature data.
#' predict_dev(
#'   h1,
#'   start_date  = "2024-03-01",
#'   start_stage = "instar1_2",
#'   gens = 5,
#'   direction = "back",
#'   keep = "gen"
#' )
#'
#'
#' @importFrom lubridate as_date
#' @importFrom dplyr bind_rows
#' @importFrom utils tail
predict_dev <- function(
    df,
    FUN = "briere2",
    params = dev_params(),
    start_date,       # YYYY-MM-DD
    start_hour  = 12, # hour in 24hr format
    start_stage = "egg",
    start_dev = NULL, # set to 0 if dir = fwd and 1 if direction = back
    gens = 1,
    direction = c("forward", "back"),
    keep = c("all", "stages", "increments", "generations"),
    ...
) {

  # check for a non-empty data.frame
  stopifnot(is(df, "data.frame"))
  if (!nrow(df)) stop("The input data frame is empty")
  direction <- match.arg(direction)
  keep <- match.arg(keep)
  FUN <- match.arg(FUN)
  # check for valid stages
  stopifnot(all(c("a", "m", "Tmin", "Tmax") %in% colnames(params)))
  start_stage <- match.arg(start_stage, rownames(params))

  # check that required variables exist in input data frame
  reqd_vars  <- c("location_key", "datetime", "obs")
  nm <- names(df)
  miss_vars <- setdiff(reqd_vars, nm)

  if (length(miss_vars) > 0) {
    msg <- paste(
      "Input data frame is missing the following required variables:",
      paste(miss_vars, collapse = ", ")
    )
    stop(msg)
  }

  # check that input data frame has correct variable classes
  reqd_class <- c("character", "POSIXct", "numeric")
  names(reqd_class) <- reqd_vars
  chk_class <- vapply(reqd_vars, \(x) is(df[[x]], reqd_class[[x]]), logical(1))
  if (!all(chk_class)) {
    wrong <- paste(reqd_vars, reqd_class, sep = ": ")[!chk_class]
    msg <- paste(
      "The following columns from df should be the classes listed:\n",
      paste(wrong, collapse = "\n")
    )
    stop(msg)
  }

  # check for mis-specified function arguments
  # if(!FUN == "briere2"){
  #   stop("The only valid FUN currently is briere2. Did you misspell it?")
  # }

  # check the start date is in the correct format
  if (!is(start_date, "Date"))
    start_date <- tryCatch(as_date(start_date, ...), warning = \(w) w)
  if (is(start_date, "simpleWarning")) stop("Failed to parse start_date")
  stopifnot(start_hour < 24) # Is this needed?

  if (!as.character(start_date) %in% as.character(lubridate::date(df$datetime))) {
    stop(
      paste(
        "The specified start_date cannot be found in the",
        "temperature data `df`.\n",
        "Check that start_date is a string in YYYY-MM-DD format")
    )
  }

  # check there is a single location only
  # To do: we might not need location check (if we don't need a location_key)
  # If we remove, then just check for no duplicated datetimes in input
  if ("location_key" %in% names(df) && length(unique(df$location_key)) > 1) {
    # datetimes must be unique
    stop("Multiple location_keys detected in 'df'. Provide data for a single location only.")
  }
  if (anyDuplicated(df$datetime) > 0) stop("There are duplicated datetimes in 'df'")

  if (is.null(start_dev)) start_dev <- as.integer(direction == "back")
  if (start_dev < 0 | start_dev > 1)
    stop("'start_dev' must be a value between 0 and 1")

  startdt <- lubridate::ymd_hms(
    paste(start_date, start_hour, sep = "-"), truncated = 2
  )

  if (direction == "forward") {
    df <- df[df$datetime >= startdt,]
    o <- order(df$datetime)
    all_stages <- rownames(params)
  } else {
    df <- df[df$datetime <= startdt,]
    o <- order(df$datetime, decreasing = TRUE)
    all_stages <- rev(rownames(params))
  }
  df <- df[o, ]

  out_gens <- vector("list", gens)
  fitted <- lubridate::Date()
  stages <- all_stages[which(all_stages == start_stage):length(all_stages)]

  for (g in seq_len(gens)) {

    # Initialise empty objects
    out <- vector("list", length(all_stages))
    names(out) <- all_stages

    for (s in all_stages) {

      tmp_df <- df[!df$datetime %in% fitted,]
      if (nrow(tmp_df)) {
        args <- c(list(df = tmp_df), direction = direction, params[s, ])
        out[[s]] <- do.call(FUN, args)
        out[[s]]$gen <- g
      } else {
        ## Handle when all dates are fitted
        out[[s]] <- data.frame(
          datetime = lubridate::Date(), obs = numeric(), gen = integer(),
          stage = character(), dev = numeric(), total_dev = numeric()
        )
      }

      if (s == start_stage & g == 1) {
        ## Only needed in the first generation?
        if (direction == "forward") {
          out[[s]] <- out[[s]][out[[s]]$total_dev < (1 - start_dev),]
          out[[s]]$total_dev <-  out[[s]]$total_dev + start_dev
        } else {
          out[[s]] <- out[[s]][out[[s]]$total_dev > (1 - start_dev),]
          out[[s]]$total_dev <-  out[[s]]$total_dev - (1 - start_dev)
        }
      }
      fitted <- lubridate::as_datetime(c(fitted, out[[s]]$datetime))

    }
    out_gens[[g]] <- bind_rows(out, .id = "stage")
  }

  # check that output is complete
  max_gen <- max(which(vapply(out_gens, nrow, integer(1)) > 0))
  max_stage <- tail(out_gens[[max_gen]]$stage, 1)
  max_dev <-  tail(out_gens[[max_gen]]$total_dev, 1)

  msg1 <- "Output may be incomplete because"
  msg2 <- "predictions exceed the time series of temperature data.\n"
  msg3 <- paste0(
    "Development is predicted to generation = ", max_gen, ", life stage = ",
    max_stage, ", and development = ", round(max_dev, 4)
  )

  # If there's a location_key in df, add this in error msg.
  # This is mainly for use with predict_development_locations
  if ("location_key" %in% names(df)) {
    msg1 <- paste0(unique(df$location_key), ": ", msg1)
  }

  # truncate to remove any empty dfs to avoid later errors
  # out_gens <- out_gens[1:max_gen]
  out_gens <- out_gens[vapply(out_gens, nrow, integer(1)) > 0]

  if (direction == "forward") {
    write_msg <- any(
      max_gen < gens, !max_stage == tail(all_stages, 1), max_dev < 0.75
    )
  } else {
    write_msg <- any(
      max_gen < gens, !max_stage == tail(all_stages, 1), max_dev > 0.25
    )
  }
  if (write_msg) message(paste(msg1, msg2, msg3))

  out_all <- vector("list", 3)
  names(out_all) <- c("increments", "stages", "generations")
  out_all$increments <- bind_rows(out_gens)
  out_all$increments$total_days <- cumsum(
    seq_along(out_all$increments$datetime) / 24
  )
  inc_cols <- c(
    "datetime", "obs", "gen", "stage", "dev", "total_dev", "total_days"
  )
  out_all$increments <- out_all$increments[inc_cols]
  out_all$stages <- dplyr::bind_rows(
    lapply(out_gens, FUN = .summarise_stages, direction = direction)
  )
  out_all$generations <- dplyr::bind_rows(
    lapply(out_gens, .summarise_gens, direction = direction)
  )

  # if (is.null(keep)) {return (out_all)}
  if (keep == "all")         {return(out_all)}
  if (keep == "increments")  {return(out_all$increments)}
  if (keep == "stages")      {return(out_all$stages)}
  if (keep == "generations") {return(out_all$generations)}

}

#' @keywords internal
#' @importFrom tidyselect all_of everything
.summarise_stages <- function(df, direction) {

  df$total_days <- cumsum(seq_along(df$datetime) / 24)
  gen_stage <- paste(df$gen, df$stage, sep = "_")
  split_df <- split(df, gen_stage)
  res <- lapply(
    split_df,
    \(x) {
      data.frame(
        gen = unique(x$gen), stage = unique(x$stage),
        start_dev = min(x$datetime), complete_dev = max(x$datetime),
        total_days = abs(diff(range(x$total_days))),
        mean_temp_oC = mean(x$obs, na.rm = TRUE)
      )
    }
  )
  res <- bind_rows(res)
  o <- order(res$complete_dev, decreasing = direction == "back")
  res <- res[o, ]
  dplyr::select(res, all_of(c("gen", "stage", "complete_dev")), everything())

}


#' @keywords internal
#' @importFrom tidyselect all_of everything
.summarise_gens <- function(df, direction) {

  df$total_days <- cumsum(seq_along(df$datetime) / 24)
  split_df <- split(df, f = df$gen)
  res <- lapply(
    split_df,
    \(x) {
      data.frame(
        gen = unique(x$gen),
        start = x$stage[1], end = x$stage[nrow(x)],
        start_dev = min(x$datetime), complete_dev = max(x$datetime),
        total_days = abs(diff(range(x$total_days))),
        mean_temp_oC = mean(x$obs, na.rm = TRUE)
      )
    }
  )
  res <- dplyr::bind_rows(res)
  res$stages <- paste(res$start, res$end, sep = " to ")
  o <- order(res$complete_dev, decreasing = direction == "back")
  res <- res[o, ]
  res <- dplyr::select(res, -all_of(c("end", "start")))
  dplyr::select(res, all_of(c("gen", "stages", "start_dev")), everything())

}
